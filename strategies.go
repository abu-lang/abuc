package main

import (
	_ "embed"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"text/template"

	"github.com/abu-lang/abuc/parser"
	"github.com/abu-lang/abuc/preprocessor"
	"github.com/antlr/antlr4/runtime/Go/antlr"
)

//go:embed goabu.go.tpl
var goabuTemplate string

type commonCompileInfo struct {
	compilerVersion string
	output          string
	system          string
	target          string
}

func makeCommonCompileInfo(sys, tgt, out string) commonCompileInfo {
	return commonCompileInfo{compilerVersion: version(),
		output: out,
		system: sys,
		target: tgt,
	}
}

func (i commonCompileInfo) outputFile(device, ext string) string {
	if i.output != "" && !os.IsPathSeparator(i.output[len(i.output)-1]) {
		return i.output + "-" + device + ext
	}
	return i.output + device + ext
}

func makeCompileStrategy(sys, tgt, out, cfg string) (compileStrategy, error) {
	com := makeCommonCompileInfo(sys, tgt, out)
	switch tgt {
	case "abu":
		return abuCompiler{
			commonCompileInfo: com,
		}, nil
	case "go":
		res := goabuCompiler{
			commonCompileInfo: com,
			template:          template.Must(template.New("goabu").Parse(goabuTemplate)),
		}
		if cfg == "" {
			return res, nil
		}
		f, err := os.Open(cfg)
		if err != nil {
			return nil, err
		}
		defer f.Close()
		err = json.NewDecoder(f).Decode(&res.config)
		if err != nil {
			return nil, err
		}
		return res, nil
	default:
		panic(errors.New("no compile strategy for target:" + tgt))
	}
}

type abuCompiler struct {
	commonCompileInfo
}

func (a abuCompiler) compile(device string, stream preprocessor.TrivialStream, st preprocessor.DeviceSymbolTable) []error {
	f, err := os.Create(a.outputFile(device, ".abu"))
	if err != nil {
		return []error{err}
	}
	defer f.Close()
	_, err = fmt.Fprintf(f, "# Code generated by abuc version %s.\n", a.compilerVersion)
	if err != nil {
		return []error{err}
	}
	_, err = fmt.Fprint(f, stream.GetText(0, stream.Size()))
	if err != nil {
		return []error{err}
	}
	return nil
}

type goabuCompiler struct {
	commonCompileInfo
	config   goabuConfig
	template *template.Template
}

func (g goabuCompiler) compile(device string, stream preprocessor.TrivialStream, st preprocessor.DeviceSymbolTable) []error {
	var toks *antlr.CommonTokenStream = nil
	abup, errs := parseAbuProgram(stream, st, &toks)
	if len(errs) > 0 {
		return errs
	}
	prog, errs := makeGoabuProgram(abup, g.config, toks)
	if len(errs) > 0 {
		return errs
	}
	f, err := os.Create(g.outputFile(device, ".go"))
	if err != nil {
		return []error{err}
	}
	defer f.Close()
	type tplData struct {
		goabuProgram
		Version string
	}
	g.template.Execute(f, tplData{Version: g.compilerVersion, goabuProgram: prog})
	return nil
}

// parseAbuProgram parses a text stream with a preprocessed abudsl program and returns an abuProgram struct.
// In the case of the occurrence of errors it returns a zero valued abuProgram and a not empty []error.
// If it receives as argument a not nil **antlr.CommonTokenStream and no errors are encountered, the argument
// is used as an output argument for returning the token stream used in the parsing.
func parseAbuProgram(stream preprocessor.TrivialStream, st preprocessor.DeviceSymbolTable, tsOut ...**antlr.CommonTokenStream) (abuProgram, []error) {
	errList := &errorHolder{}
	is := antlr.NewInputStream(stream.GetText(0, stream.Size()-1))
	lex := parser.NewAbuLexer(is)
	lex.RemoveErrorListeners()
	lex.AddErrorListener(errList)
	toks := antlr.NewCommonTokenStream(lex, antlr.TokenDefaultChannel)
	par := parser.NewAbuParser(toks)
	par.RemoveErrorListeners()
	par.AddErrorListener(errList)
	par.BuildParseTrees = true
	list := newAbuParser(st, errList.addError)
	tree := par.Program()
	antlr.ParseTreeWalkerDefault.Walk(list, tree)
	if len(errList.errors) > 0 {
		return abuProgram{}, errList.errors
	}
	if len(tsOut) > 0 {
		if tsOut[0] != nil {
			*tsOut[0] = toks
		}
	}
	return list.abuProgram, nil
}

type errorHolder struct {
	*antlr.DefaultErrorListener
	errors []error
}

func (h *errorHolder) SyntaxError(recognizer antlr.Recognizer, offendingSymbol interface{}, line, column int, msg string, e antlr.RecognitionException) {
	h.addError(fmt.Errorf("line %d:%d %s", line, column, msg))
}

func (h *errorHolder) addError(err error) {
	h.errors = append(h.errors, err)
}
