// Copyright 2022 Massimo Comuzzo, Michele Pasqua and Marino Miculan
// SPDX-License-Identifier: Apache-2.0

package main

import (
	_ "embed"
	"errors"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"sync"
	"text/template"

	"github.com/abu-lang/abuc/parser"
	"github.com/abu-lang/abuc/preprocessor"
	"github.com/antlr/antlr4/runtime/Go/antlr"
)

//go:embed goabu.go.tpl
var goabuTemplate string

type commonCompileInfo struct {
	compilerVersion string
	output          string
	system          string
	target          string
}

func makeCommonCompileInfo(sys, tgt, out string) commonCompileInfo {
	return commonCompileInfo{compilerVersion: version(),
		output: out,
		system: sys,
		target: tgt,
	}
}

func outputFile(output, device, ext string) string {
	if output != "" && !os.IsPathSeparator(output[len(output)-1]) {
		return output + "-" + device + ext
	}
	return output + device + ext
}

// Close is a no-op for implementing compileStrategy.Close
// in simple strategies.
func (i commonCompileInfo) Close() error {
	return nil
}

func makeCompileStrategy(sys, tgt, out, cfg string) (compileStrategy, error) {
	com := makeCommonCompileInfo(sys, tgt, out)
	switch tgt {
	case "abu":
		return abuCompiler{
			commonCompileInfo: com,
		}, nil
	case "go":
		conf, err := readGoabuConfig(cfg)
		if err != nil {
			return nil, err
		}
		return goabuCompiler{
			commonCompileInfo: com,
			config:            conf,
			template:          template.Must(template.New("goabu").Parse(goabuTemplate)),
		}, nil
	case "arm64", "amd64":
		conf, err := readGoabuConfig(cfg)
		if err != nil {
			return nil, err
		}
		wd, err := os.MkdirTemp("", "abuc-")
		if err != nil {
			return nil, err
		}
		goDest := wd + string(os.PathSeparator)
		if out != "" && !os.IsPathSeparator(out[len(out)-1]) {
			goDest = filepath.Join(wd, filepath.Base(out))
		}
		gs, err := makeCompileStrategy(sys, "go", goDest, cfg)
		if err != nil {
			os.Remove(wd)
			return nil, err
		}
		return machineCodeCompiler{
			commonCompileInfo: com,
			additionalFiles:   basenames(conf.AdditionalFiles),
			goDest:            goDest,
			goCompiler:        gs,
			workDir:           wd,
			ready:             prepareWorkDir(wd, conf.AdditionalFiles),
		}, nil
	default:
		panic(errors.New("no compile strategy for target:" + tgt))
	}
}

// basenames returns the base names of the argument's elements.
func basenames(paths []string) []string {
	res := make([]string, 0, len(paths))
	for _, p := range paths {
		res = append(res, filepath.Base(p))
	}
	return res
}

func prepareWorkDir(wd string, files []string) <-chan error {
	res := make(chan error)
	go func(done chan<- error) {
		var err error
		defer func() {
			for {
				done <- err
			}
		}()
		if !runCommand(wd, "go", "mod", "init", filepath.Base(wd)) {
			err = errors.New("could not initialize Go module")
			return
		}
		if len(files) > 0 {
			err = copyFiles(wd, files)
			if err != nil {
				return
			}
			// possibly fetch dependencies from additional files (not mandatory)
			runCommand(wd, "go", "mod", "tidy")
		}
		if !runCommand(wd, "go", "get", "github.com/abu-lang/goabu@"+goabuVersion) {
			err = errors.New("could not fetch GoAbU")
		}
	}(res)
	return res
}

// runCommand takes as argument a directory path and the arguments of a command.
// The command will be executed in the specified directory and the returned bool
// indicates wheter the command completed successfully or not.
func runCommand(workDir, name string, arg ...string) bool {
	cmd := exec.Command(name, arg...)
	cmd.Dir = workDir
	return nil == cmd.Run()
}

// copyFiles takes as argument a directory path and a slice of
// file paths and tries to copy the specified files in the indicated
// directory.
func copyFiles(dest string, files []string) error {
	for _, p := range files {
		r, err := os.Open(p)
		if err != nil {
			return err
		}
		w, err := os.Create(filepath.Join(dest, p))
		if err != nil {
			return err
		}
		_, err = io.Copy(w, r)
		if err != nil {
			return err
		}
	}
	return nil
}

type abuCompiler struct {
	commonCompileInfo
}

func (a abuCompiler) compile(device string, stream preprocessor.TrivialStream, st preprocessor.DeviceSymbolTable) []error {
	f, err := os.Create(outputFile(a.output, device, ".abu"))
	if err != nil {
		return []error{err}
	}
	defer f.Close()
	_, err = fmt.Fprintf(f, "# Code generated by abuc version %s.\n", a.compilerVersion)
	if err != nil {
		return []error{err}
	}
	_, err = fmt.Fprint(f, stream.GetText(0, stream.Size()))
	if err != nil {
		return []error{err}
	}
	return nil
}

type goabuCompiler struct {
	commonCompileInfo
	config   goabuConfig
	template *template.Template
}

func (g goabuCompiler) compile(device string, stream preprocessor.TrivialStream, st preprocessor.DeviceSymbolTable) []error {
	var toks *antlr.CommonTokenStream = nil
	abup, errs := parseAbuProgram(stream, st, &toks)
	if len(errs) > 0 {
		return errs
	}
	prog, errs := makeGoabuProgram(abup, g.config, toks)
	if len(errs) > 0 {
		return errs
	}
	f, err := os.Create(outputFile(g.output, device, ".go"))
	if err != nil {
		return []error{err}
	}
	defer f.Close()
	type tplData struct {
		goabuProgram
		Version string
	}
	g.template.Execute(f, tplData{Version: g.compilerVersion, goabuProgram: prog})
	return nil
}

// parseAbuProgram parses a text stream with a preprocessed abudsl program and returns an abuProgram struct.
// In the case of the occurrence of errors it returns a zero valued abuProgram and a not empty []error.
// If it receives as argument a not nil **antlr.CommonTokenStream and no errors are encountered, the argument
// is used as an output argument for returning the token stream used in the parsing.
func parseAbuProgram(stream preprocessor.TrivialStream, st preprocessor.DeviceSymbolTable, tsOut ...**antlr.CommonTokenStream) (abuProgram, []error) {
	errList := &errorHolder{}
	is := antlr.NewInputStream(stream.GetText(0, stream.Size()-1))
	lex := parser.NewAbuLexer(is)
	lex.RemoveErrorListeners()
	lex.AddErrorListener(errList)
	toks := antlr.NewCommonTokenStream(lex, antlr.TokenDefaultChannel)
	par := parser.NewAbuParser(toks)
	par.RemoveErrorListeners()
	par.AddErrorListener(errList)
	par.BuildParseTrees = true
	list := newAbuParser(st, errList.addError)
	tree := par.Program()
	antlr.ParseTreeWalkerDefault.Walk(list, tree)
	if len(errList.errors) > 0 {
		return abuProgram{}, errList.errors
	}
	if len(tsOut) > 0 {
		if tsOut[0] != nil {
			*tsOut[0] = toks
		}
	}
	return list.abuProgram, nil
}

type machineCodeCompiler struct {
	commonCompileInfo

	goDest     string
	goCompiler compileStrategy

	additionalFiles []string
	workDir         string
	ready           <-chan error
	tidyOnce        sync.Once
}

func (m machineCodeCompiler) Close() error {
	err := m.goCompiler.Close()
	if err != nil {
		return err
	}
	<-m.ready
	// RemoveAll fails silently with "" as argument
	// See https://github.com/golang/go/issues/28830
	if m.workDir == "" {
		return errors.New("invalid temporary working directory")
	}
	return os.RemoveAll(m.workDir)
}

func (m machineCodeCompiler) compile(device string, stream preprocessor.TrivialStream, st preprocessor.DeviceSymbolTable) []error {
	// transpile from abudsl to Go
	errs := m.goCompiler.compile(device, stream, st)
	if len(errs) > 0 {
		return errs
	}
	// wait for working directory preparations
	err := <-m.ready
	if err != nil {
		return []error{err}
	}
	// fetch dependencies
	m.tidyOnce.Do(func() {
		if !runCommand(m.workDir, "go", "mod", "tidy") {
			err = errors.New("error in fetching the required dependencies")
		}
	})
	if err != nil {
		return []error{err}
	}
	// construct go build command
	comp := exec.Command("go")
	comp.Dir = m.workDir
	comp.Env = append(os.Environ(), "GOOS="+m.system, "GOARCH="+m.target)
	comp.Args = make([]string, 0, 5+len(m.additionalFiles))
	dst, err := filepath.Abs(filepath.Dir(m.output))
	if err != nil {
		return []error{err}
	}
	dst = dst + string(os.PathSeparator) // (create directory if missing)
	comp.Args = append(comp.Args, "go", "build", "-o", dst, filepath.Base(outputFile(m.goDest, device, ".go")))
	comp.Args = append(comp.Args, m.additionalFiles...)
	// compile go sources
	_, err = comp.Output()
	if err != nil {
		return []error{errors.New(string(err.(*exec.ExitError).Stderr))}
	}
	return nil
}

type errorHolder struct {
	*antlr.DefaultErrorListener
	errors []error
}

func (h *errorHolder) SyntaxError(recognizer antlr.Recognizer, offendingSymbol interface{}, line, column int, msg string, e antlr.RecognitionException) {
	h.addError(fmt.Errorf("line %d:%d %s", line, column, msg))
}

func (h *errorHolder) addError(err error) {
	h.errors = append(h.errors, err)
}
